Index: src/main/java/database/MongoDBAccess.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package database;\n\nimport com.mongodb.*;\nimport responseModel.Schedule.ScheduleItemResponseModel;\nimport responseModel.Task.TaskResponseModel;\nimport requestModel.ImportRequestModel;\nimport useCaseInteractor.DataAccess;\nimport java.util.ArrayList;\n\npublic class MongoDBAccess implements DataAccess {\n\n    private final String username;\n\n    private final DBCollection collection;\n\n    public MongoDBAccess(DBCollection collection, String username) {\n\n        this.username = username;\n        this.collection = collection;\n    }\n\n    @Override\n    public boolean createUser(String password, String fName, String lName){\n        if(this.getUserExist()){\n            return false;\n        }\n        ArrayList<Object> schedules = new ArrayList<>();\n        ArrayList<Object> tasks = new ArrayList<>();\n        ArrayList<Object> followers = new ArrayList<>();\n        ArrayList<Object> requests = new ArrayList<>();\n        DBObject person = new BasicDBObject(\"_id\", this.username)\n                .append(\"password\", password).append(\"firstName\", fName).append(\"lastName\", lName)\n                .append(\"schedules\", schedules).append(\"tasks\", tasks)\n                .append(\"followers\", followers)\n                .append(\"requests\", requests);\n        collection.insert(person);\n        return true;\n    }\n\n    @Override\n    public void resetSchedule(){\n        DBObject query = new BasicDBObject(\"_id\", this.username);\n        ArrayList<Object> lst = new ArrayList<>();\n        DBObject updateObj = new BasicDBObject(\"schedules\", lst);\n        this.collection.update(query, new BasicDBObject(\"$set\", updateObj));\n    }\n\n    @Override\n    public void resetTask(){\n        DBObject query = new BasicDBObject(\"_id\", this.username);\n        ArrayList<Object> lst = new ArrayList<>();\n        DBObject updateObj = new BasicDBObject(\"tasks\", lst);\n        this.collection.update(query, new BasicDBObject(\"$set\", updateObj));\n    }\n\n    @Override\n    public void setSchedule(ScheduleItemResponseModel responseModel) {\n        DBObject query = new BasicDBObject(\"_id\", this.username);\n        ArrayList<Object> lst = new ArrayList<>();\n        lst.add(responseModel.getTitle());\n        lst.add(responseModel.getStartDate().toString());\n        lst.add(responseModel.getEndDate().toString());\n        lst.add(responseModel.getStartTime().toString());\n        lst.add(responseModel.getEndTime().toString());\n        DBObject updateObj = new BasicDBObject(\"schedules\", lst);\n        this.collection.update(query, new BasicDBObject(\"$push\", updateObj));\n    }\n\n    @Override\n    public void setImportSchedule(ImportRequestModel requestModel) {\n        DBObject query = new BasicDBObject(\"_id\", this.username);\n        ArrayList<Object> lst = new ArrayList<>();\n        for(int i = 0; i < requestModel.getTitles().size(); i++) {\n            lst.add(requestModel.getTitles().get(i));\n            lst.add(requestModel.getStartDates().get(i));\n            lst.add(requestModel.getEndDates().get(i));\n            lst.add(requestModel.getStartTime().get(i));\n            lst.add(requestModel.getEndTime().get(i));\n            DBObject updateObj = new BasicDBObject(\"schedules\", lst);\n            this.collection.update(query, new BasicDBObject(\"$push\", updateObj));\n            lst.remove(requestModel.getTitles().get(i));\n            lst.remove(requestModel.getStartDates().get(i));\n            lst.remove(requestModel.getEndDates().get(i));\n            lst.remove(requestModel.getStartTime().get(i));\n            lst.remove(requestModel.getEndTime().get(i));\n        }\n    }\n\n    @Override\n    public ArrayList<Object> getSingleSchedule(ScheduleItemResponseModel responseModel) {\n        ArrayList<Object> lst = new ArrayList<>();\n        lst.add(responseModel.getTitle());\n        lst.add(responseModel.getStartDate());\n        lst.add(responseModel.getEndDate());\n        lst.add(responseModel.getStartTime());\n        lst.add(responseModel.getEndTime());\n\n        ArrayList<ArrayList<Object>> entireSchedule = this.getUserEntireSchedule();\n\n        for (ArrayList<Object> objects : entireSchedule) {\n            if (objects.equals(lst)) {\n                return objects;\n            }\n        }\n        return lst;\n    }\n\n    @Override\n    public ArrayList<ArrayList<Object>>  getUserEntireSchedule() {\n        DBObject document = collection.findOne(this.username);\n        BasicDBList list = (BasicDBList) document.get(\"schedules\");\n        ArrayList<ArrayList<Object>> entireList = new ArrayList<>();\n        for (Object sublist: list) {\n            entireList.add((ArrayList<Object>) sublist);\n        }\n        return entireList;\n    }\n\n    @Override\n    public void deleteScheduleItem(ScheduleItemResponseModel responseModel) {\n        DBObject query = new BasicDBObject(\"_id\", this.username);\n\n        ArrayList<Object> lst = new ArrayList<>();\n        lst.add(responseModel.getTitle());\n        lst.add(responseModel.getStartDate());\n        lst.add(responseModel.getEndDate());\n        lst.add(responseModel.getStartTime());\n        lst.add(responseModel.getEndTime());\n\n        ArrayList<ArrayList<Object>> entireSchedule = this.getUserEntireSchedule();\n\n        for (ArrayList<Object> objects : entireSchedule) {\n            if (objects.equals(lst)) {\n                entireSchedule.remove(objects);\n                DBObject updateObj = new BasicDBObject(\"schedules\", entireSchedule);\n                collection.update(query, new BasicDBObject(\"$set\", updateObj));\n            }\n        }\n    }\n\n    @Override\n    public void setTask(TaskResponseModel responseModel) {\n        DBObject query = new BasicDBObject(\"_id\", this.username);\n        ArrayList<Object> lst = new ArrayList<>();\n        lst.add(responseModel.getDescription());\n        lst.add(responseModel.getDate().toString());\n        lst.add(responseModel.getCategory());\n        DBObject updateObj = new BasicDBObject(\"tasks\", lst);\n        this.collection.update(query, new BasicDBObject(\"$push\", updateObj));\n    }\n\n    @Override\n    public ArrayList<Object> getSingleTask(TaskResponseModel responseModel) {\n        ArrayList<Object> lst = new ArrayList<>();\n        lst.add(responseModel.getDescription());\n        lst.add(responseModel.getDate().toString());\n        lst.add(responseModel.getCategory());\n\n        ArrayList<ArrayList<Object>> entireTask = this.getUserEntireTask();\n\n        for (ArrayList<Object> objects : entireTask) {\n            if (objects.equals(lst)) {\n                return objects;\n            }\n        }\n        return lst;\n    }\n\n    @Override\n    public ArrayList<ArrayList<Object>> getUserEntireTask() {\n        DBObject document = collection.findOne(this.username);\n        BasicDBList list = (BasicDBList) document.get(\"tasks\");\n        ArrayList<ArrayList<Object>> entireList = new ArrayList<>();\n        for (Object sublist: list) {\n            entireList.add((ArrayList<Object>) sublist);\n        }\n        return entireList;\n    }\n\n    @Override\n    public void deleteTask(TaskResponseModel responseModel) {\n        DBObject query = new BasicDBObject(\"_id\", this.username);\n\n        ArrayList<Object> lst = new ArrayList<>();\n        lst.add(responseModel.getDescription());\n        lst.add(responseModel.getDate().toString());\n        lst.add(responseModel.getCategory());\n\n        ArrayList<ArrayList<Object>> entireTask = this.getUserEntireTask();\n\n        for (ArrayList<Object> objects : entireTask) {\n            if (objects.equals(lst)) {\n                entireTask.remove(objects);\n                DBObject updateObj = new BasicDBObject(\"tasks\", entireTask);\n                collection.update(query, new BasicDBObject(\"$set\", updateObj));\n            }\n        }\n    }\n    @Override\n    public boolean getTaskExist(TaskResponseModel responseModel) {\n        ArrayList<ArrayList<Object>> entireTask = this.getUserEntireTask();\n\n        ArrayList<Object> lst = new ArrayList<>();\n        lst.add(responseModel.getDescription());\n        lst.add(responseModel.getDate().toString());\n        lst.add(responseModel.getCategory());\n        for (ArrayList<Object> objects : entireTask) {\n            if (objects.equals(lst)){\n                //return true if task exists\n                return true;\n            }\n        }\n        //return false if task does not exist\n        return false;\n    }\n    @Override\n    public boolean getUserExist(String username){\n        return this.collection.findOne(username) != null;\n    }\n\n\n    @Override\n    public boolean getUserExist(){ return this.collection.findOne(this.username) != null;}\n\n    //returns all user data\n    @Override\n    public DBObject getUserData(){\n        return collection.findOne(this.username);\n    }\n\n    //reset/setting password\n    @Override\n    public void setPassword(String password){\n        DBObject query = new BasicDBObject(\"_id\", this.username);\n\n        DBObject updateObj = new BasicDBObject(\"password\", password);\n\n        collection.update(query, updateObj);\n    }\n\n    //returns following list\n    @Override\n    public Object getFollowing(){\n        return collection.findOne(this.username).get(\"followers\");\n    }\n\n    //add follower to following list\n    @Override\n    public void appendFollowing(String username){\n        DBObject query = new BasicDBObject(\"_id\", this.username);\n\n        DBObject updateObj = new BasicDBObject(\"followers\", username);\n\n        collection.update(query, new BasicDBObject(\"$push\", updateObj));\n    }\n\n    @Override\n    public boolean checkPassword(String password){\n        return collection.findOne(this.username).get(\"password\").equals(password);\n    }\n\n    @Override\n    public void setFollowing(ArrayList<String> following){\n        DBObject query = new BasicDBObject(\"_id\", this.username);\n\n        DBObject updateObj = new BasicDBObject(\"followers\", this.username);\n\n        this.collection.update(query, updateObj);\n    }\n    //returns current request, you can accept or decline a request\n    @Override\n    public Object getRequests(){\n        return collection.findOne(this.username).get(\"requests\");\n    }\n\n    //adds a request to list of requests.\n    @Override\n    public void appendRequests(String username){\n        DBObject query = new BasicDBObject(\"_id\", this.username);\n\n        DBObject updateObj = new BasicDBObject(\"requests\", username);\n\n        collection.update(query, new BasicDBObject(\"$push\", updateObj));\n    }\n\n    //sets a new request list when a request is accepted or declined\n    @Override\n    public void setRequests(ArrayList<String> usernames){\n        DBObject query = new BasicDBObject(\"_id\", this.username);\n\n        DBObject updateObj = new BasicDBObject(\"requests\", this.username);\n\n        this.collection.update(query, updateObj);\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/database/MongoDBAccess.java b/src/main/java/database/MongoDBAccess.java
--- a/src/main/java/database/MongoDBAccess.java	(revision b73e3a07a2cd621cff232f915b7c8c658e66b6cd)
+++ b/src/main/java/database/MongoDBAccess.java	(date 1670236931083)
@@ -1,6 +1,7 @@
 package database;
 
 import com.mongodb.*;
+import requestModel.ScheduleItemRequestModel;
 import responseModel.Schedule.ScheduleItemResponseModel;
 import responseModel.Task.TaskResponseModel;
 import requestModel.ImportRequestModel;
@@ -37,6 +38,7 @@
         return true;
     }
 
+    
     @Override
     public void resetSchedule(){
         DBObject query = new BasicDBObject("_id", this.username);
@@ -217,7 +219,18 @@
     public boolean getUserExist(String username){
         return this.collection.findOne(username) != null;
     }
-
+    @Override
+    public boolean getScheduleExist(ScheduleItemRequestModel request){
+        ArrayList<ArrayList<Object>> schedules = this.getUserEntireSchedule();
+        for(ArrayList<Object> schedule : schedules){
+            if((schedule.get(0) == request.getTitle()) && (schedule.get(1) == request.getStartDate()) &&
+                    (schedule.get(2) == request.getEndDate()) && (schedule.get(3) == request.getStartTime()) &&
+                    (schedule.get(4) == request.getEndTime())){
+                return true;
+            }
+        }
+        return false;
+    }
 
     @Override
     public boolean getUserExist(){ return this.collection.findOne(this.username) != null;}
Index: src/main/java/useCaseInteractor/DataAccess.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package useCaseInteractor;\n\nimport requestModel.ImportRequestModel;\nimport requestModel.ScheduleItemRequestModel;\nimport requestModel.TaskRequestModel;\nimport responseModel.Schedule.ScheduleItemResponseModel;\nimport responseModel.Task.TaskResponseModel;\n\nimport java.util.ArrayList;\n\npublic interface DataAccess {\n\n    boolean createUser(String password, String fName, String lName);\n\n    void resetSchedule();\n\n    void resetTask();\n\n    void setSchedule(ScheduleItemResponseModel responseModel);\n\n    ArrayList<Object> getSingleSchedule(ScheduleItemResponseModel responseModel);\n\n    void setImportSchedule(ImportRequestModel requestModel);\n\n    ArrayList<ArrayList<Object>> getUserEntireSchedule();\n\n    void deleteScheduleItem(ScheduleItemResponseModel responseModel);\n\n    void setTask(TaskResponseModel responseModel);\n\n    ArrayList<Object> getSingleTask(TaskResponseModel responseModel);\n\n    ArrayList<ArrayList<Object>> getUserEntireTask();\n\n    void deleteTask(TaskResponseModel responseModel);\n\n    boolean getTaskExist(TaskResponseModel responseModel);\n\n    boolean getUserExist(String username);\n\n    boolean getUserExist();\n\n    Object getUserData();\n\n    void setPassword(String password);\n\n    Object getFollowing();\n\n    void appendFollowing(String username);\n\n    boolean checkPassword(String password);\n\n    void setFollowing(ArrayList<String> following);\n\n    Object getRequests();\n\n    void appendRequests(String username);\n\n    //sets a new request list when a request is accepted or declined\n    void setRequests(ArrayList<String> usernames);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/useCaseInteractor/DataAccess.java b/src/main/java/useCaseInteractor/DataAccess.java
--- a/src/main/java/useCaseInteractor/DataAccess.java	(revision b73e3a07a2cd621cff232f915b7c8c658e66b6cd)
+++ b/src/main/java/useCaseInteractor/DataAccess.java	(date 1670236901015)
@@ -12,6 +12,8 @@
 
     boolean createUser(String password, String fName, String lName);
 
+    boolean getScheduleExist(ScheduleItemRequestModel request);
+
     void resetSchedule();
 
     void resetTask();
Index: src/main/java/presenter/TimetablePresenter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package presenter;\n\nimport boundary.Schedule.UpdateScheduleInputBoundary;\nimport com.calendarfx.model.Calendar;\nimport com.calendarfx.model.Entry;\nimport com.calendarfx.view.CalendarView;\nimport controller.Schedule.TimetableController;\nimport database.MongoDBAccess;\nimport entity.Schedule.CommonScheduleItemFactory;\nimport entity.Schedule.ScheduleItemFactory;\nimport javafx.animation.FadeTransition;\nimport javafx.fxml.FXMLLoader;\nimport javafx.scene.control.DatePicker;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.TextField;\nimport javafx.scene.layout.GridPane;\nimport javafx.stage.Stage;\nimport javafx.util.Duration;\nimport entity.Schedule.TimeManagement;\nimport main.LoginPage;\nimport main.collectCollection;\nimport requestModel.ScheduleItemRequestModel;\nimport useCaseInteractor.DataAccess;\nimport useCaseInteractor.Schedule.UpdateScheduleItem;\nimport useCaseInteractor.User.userCollection;\n\nimport java.io.IOException;\nimport java.net.UnknownHostException;\nimport java.text.SimpleDateFormat;\nimport java.time.LocalDate;\nimport java.time.LocalTime;\nimport java.util.*;\n\n\npublic class TimetablePresenter {\n\n    private final TimeManagement TM  = new TimeManagement();\n\n    public void loadSchedule(CalendarView calendar, ArrayList<ArrayList<Object>> entireSchedule) {\n        for (Calendar temp : calendar.getCalendars()) {\n            temp.clear();\n            for (ArrayList<Object> schedule : entireSchedule) {\n                temp.addEntry(createEntry(schedule));\n            }\n        }\n    }\n\n    public Entry<String> createEntry(ArrayList<Object> schedule) {\n        Entry<String> entry = new Entry<>((String) schedule.get(0));\n\n        String[] startDate = ((String )schedule.get(1)).split(\"-\");\n        String[] endDate = ((String )schedule.get(2)).split(\"-\");\n        String[] startTime = ((String )schedule.get(3)).split(\":\");\n        String[] endTime = ((String )schedule.get(4)).split(\":\");\n\n        entry.setInterval(LocalDate.now());\n        entry.changeStartDate(LocalDate.of(\n                Integer.parseInt(startDate[0]), Integer.parseInt(startDate[1]), Integer.parseInt(startDate[2])));\n        entry.changeEndDate(LocalDate.of(\n                Integer.parseInt(endDate[0]), Integer.parseInt(endDate[1]), Integer.parseInt(endDate[2])));\n        entry.changeStartTime(LocalTime.of(Integer.parseInt(startTime[0]),Integer.parseInt(startTime[1])));\n        entry.changeEndTime(LocalTime.of(Integer.parseInt(endTime[0]),Integer.parseInt(endTime[1])));\n        return entry;\n    }\n    public void printCalendarEntries(Label entriesSaved) throws UnknownHostException {\n        CalendarView calendar = TimetableController.calendar;\n        Set<String> newSet = null;\n        Map map = new HashMap();\n        DataAccess dataAccess = new MongoDBAccess(collectCollection.main(), userCollection.getUsername());\n        for (Calendar temp : calendar.getCalendars()) {\n            map = temp.findEntries(TM.getStartDate(), TM.getEndDate(), TM.getTimeZone());\n        }\n        newSet = new HashSet<>();\n        for (Object entry : map.values()) {\n            String singleDayData = entry.toString();\n            while (singleDayData.contains(\"],\")) {\n                String substring = singleDayData.substring(0, singleDayData.indexOf(\"],\") + 3);\n                singleDayData = singleDayData.substring(singleDayData.indexOf(\"],\") + 3);\n                newSet.add(substring);\n            }\n            newSet.add(singleDayData);\n        }\n\n        dataAccess.resetSchedule();\n        for (String s : newSet) {\n            findEntryData(s);\n        }\n        entriesSaved.setText(\"ALL ENTIRES SAVED\");\n        FadeTransition ft = new FadeTransition(Duration.millis(1850), entriesSaved);\n        ft.setFromValue(1.0);\n        ft.setToValue(0.0);\n        ft.setAutoReverse(true);\n        ft.play();\n        }\n\n\n    public void findEntryData(Object entry) throws UnknownHostException {\n        //Finds the title in the values of the map\n        int title_start = entry.toString().toUpperCase().indexOf(\"TITLE=\") + (\"TITLE=\").length();\n        int title_end = entry.toString().toUpperCase().indexOf(\",\");\n        String title = entry.toString().substring(title_start, title_end);\n\n        //Finds the start date in the values of the map\n        int startDate_start = entry.toString().toUpperCase().indexOf(\"STARTDATE=\") + (\"STARTDATE=\").length();\n        int startDate_end = startDate_start + 10;\n        String startDate = entry.toString().substring(startDate_start, startDate_end);\n\n        //Finds the end date in the values of the map\n        int endDate_start = entry.toString().toUpperCase().indexOf(\"ENDDATE=\") + (\"ENDDATE=\").length();\n        int endDate_end = endDate_start + 10;\n        String endDate = entry.toString().substring(endDate_start, endDate_end);\n\n        //Finds the start time in the values of the map\n        int startTime_start = entry.toString().toUpperCase().indexOf(\"STARTTIME=\") + (\"STARTTIME=\").length();\n        int startTime_end = startTime_start + 5;\n        String startTime = entry.toString().substring(startTime_start, startTime_end);\n\n        //Finds the end time in the values of the map\n        int endTime_start = entry.toString().toUpperCase().indexOf(\"ENDTIME=\") + (\"ENDTIME=\").length();\n        int endTime_end = endTime_start + 5;\n        String endTime = entry.toString().substring(endTime_start, endTime_end);\n//        System.out.println(\"Event\" + \": \" + title + \", \" + startDate + \", \" + endDate +\n//                \", \" + startTime + \", \" + endTime);\n            String[] newStartDate = startDate.split(\"-\");\n            String[] newEndDate = endDate.split(\"-\");\n            String[] newStartTime = startTime.split(\":\");\n            String[] newEndTime = endTime.split(\":\");\n//            System.out.println(newStartDate[0] + \", \"+newEndDate.toString()+\", \"+newStartTime[0]+\", \"+newEndDate.toString());\n            ScheduleItemFactory item = new CommonScheduleItemFactory();\n            DataAccess dataAccess = new MongoDBAccess(collectCollection.main(), userCollection.getUsername());\n            UpdateScheduleInputBoundary addSchedule = new UpdateScheduleItem(dataAccess, item);\n            ScheduleItemRequestModel request = new ScheduleItemRequestModel(title, LocalDate.of(Integer.parseInt(newStartDate[0]),\n                    Integer.parseInt(newStartDate[1]),Integer.parseInt(newStartDate[2])), LocalDate.of(Integer.parseInt(newEndDate[0]),\n                    Integer.parseInt(newEndDate[1]),Integer.parseInt(newEndDate[2])),\n                    LocalTime.of(Integer.parseInt(newStartTime[0]),Integer.parseInt(newStartTime[1])), LocalTime.of(Integer.parseInt(newEndTime[0]),Integer.parseInt(newEndTime[1])));\n\n            addSchedule.create(request);\n    }\n\n    public void addScheduleAction(TextField scheduleTitle, DatePicker startDate, DatePicker endDate,\n                                  TextField startTime, TextField endTime, Label errorMessage) {\n        CalendarView calendar = TimetableController.calendar;\n\n        if (isNotBlank(scheduleTitle, startDate, endDate, startTime, endTime)) {\n            errorMessage.setText(\"Please Fill in All Fields\".toUpperCase());\n            FadeTransition FTBlank = new FadeTransition(Duration.millis(2850), errorMessage);\n            FTBlank.setFromValue(1.0);\n            FTBlank.setToValue(0.0);\n            FTBlank.setAutoReverse(true);\n            FTBlank.play();\n        }\n        if (!inputTimeChecker(startTime.getText(), endTime.getText())) {\n            errorMessage.setText(\"Please Fill a Valid Time as HH:MM\".toUpperCase());\n            FadeTransition FTNotValidTime = new FadeTransition(Duration.millis(3950), errorMessage);\n            FTNotValidTime.setFromValue(1.0);\n            FTNotValidTime.setToValue(0.0);\n            FTNotValidTime.setAutoReverse(true);\n            FTNotValidTime.play();\n        }\n        if (startDate.getValue().isAfter(endDate.getValue()) || endDate.getValue().isBefore(startDate.getValue())) {\n            errorMessage.setText(\"Start date can't be after the end date\".toUpperCase());\n            FadeTransition FTNotValidDate = new FadeTransition(Duration.millis(3950), errorMessage);\n            FTNotValidDate.setFromValue(1.0);\n            FTNotValidDate.setToValue(0.0);\n            FTNotValidDate.setAutoReverse(true);\n            FTNotValidDate.play();\n        }\n\n        String[] arrayStartTime = startTime.getText().split(\":\");\n        String[] arrayEndTime = endTime.getText().split(\":\");\n        LocalTime LTS = LocalTime.of(Integer.parseInt(arrayStartTime[0]), Integer.parseInt(arrayStartTime[1]));\n        LocalTime LTE = LocalTime.of(Integer.parseInt(arrayEndTime[0]), Integer.parseInt(arrayEndTime[1]));\n\n        if (LTS.isAfter(LTE) || LTE.isBefore(LTS)){\n            errorMessage.setText(\"Start time can't be after the end time\".toUpperCase());\n            FadeTransition FTNotValidTime = new FadeTransition(Duration.millis(3950), errorMessage);\n            FTNotValidTime.setFromValue(1.0);\n            FTNotValidTime.setToValue(0.0);\n            FTNotValidTime.setAutoReverse(true);\n            FTNotValidTime.play();\n        }\n        //Makes the event with the name scheduleTitle\n        Entry entry = new Entry(scheduleTitle.getText());\n        //sets the days and time for the entry.\n        entry.setInterval(startDate.getValue(), LTS, endDate.getValue(), LTE);\n        for (Calendar temp : calendar.getCalendars()) {\n            temp.addEntry(entry);\n        }\n        Stage stage = (Stage) scheduleTitle.getScene().getWindow();\n        stage.close();\n    }\n\n    public boolean inputTimeChecker(String startTime, String endTime) {\n        String[] time = (startTime + \":\" + endTime).split(\":\");\n        //if startTime = \"12:30\" and endTime is \"2:15\", then time = [\"12\", \"30\", \"2\", \"15\"]\n        return (startTime.matches(\"\\\\d{2}:\\\\d{2}\") || startTime.matches(\"\\\\d:\\\\d{2}\")) &&\n                (endTime.matches(\"\\\\d{2}:\\\\d{2}\") || endTime.matches(\"\\\\d:\\\\d{2}\")) &&\n                (Integer.parseInt(time[0]) <= 12) && (Integer.parseInt(time[0]) > 0) &&\n                (Integer.parseInt(time[2]) <= 12) && (Integer.parseInt(time[2]) > 0) &&\n                (Integer.parseInt(time[1]) <= 59) && (Integer.parseInt(time[3]) <= 59);\n    }\n    public boolean isNotBlank(TextField scheduleTitle, DatePicker startDate, DatePicker endDate,\n                              TextField startTime, TextField endTime) {\n        if (scheduleTitle.getText().isBlank() || (startDate == null) || (endDate == null) ||\n                startTime.getText().isBlank() || endTime.getText().isBlank()) {\n            return true;\n        }\n        return false;\n    }\n\n    public void loadTODO(GridPane TODO) throws IOException {\n        FXMLLoader fxmlLoader = new FXMLLoader(LoginPage.class.getClassLoader().getResource(\"todo.fxml\"));\n        TODO.getChildren().add(fxmlLoader.load());\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/presenter/TimetablePresenter.java b/src/main/java/presenter/TimetablePresenter.java
--- a/src/main/java/presenter/TimetablePresenter.java	(revision b73e3a07a2cd621cff232f915b7c8c658e66b6cd)
+++ b/src/main/java/presenter/TimetablePresenter.java	(date 1670236901011)
@@ -133,10 +133,12 @@
                     Integer.parseInt(newStartDate[1]),Integer.parseInt(newStartDate[2])), LocalDate.of(Integer.parseInt(newEndDate[0]),
                     Integer.parseInt(newEndDate[1]),Integer.parseInt(newEndDate[2])),
                     LocalTime.of(Integer.parseInt(newStartTime[0]),Integer.parseInt(newStartTime[1])), LocalTime.of(Integer.parseInt(newEndTime[0]),Integer.parseInt(newEndTime[1])));
-
-            addSchedule.create(request);
-    }
+            if(!dataAccess.getScheduleExist(request)){
+                addSchedule.create(request);
+            }
 
+    }
+
     public void addScheduleAction(TextField scheduleTitle, DatePicker startDate, DatePicker endDate,
                                   TextField startTime, TextField endTime, Label errorMessage) {
         CalendarView calendar = TimetableController.calendar;
